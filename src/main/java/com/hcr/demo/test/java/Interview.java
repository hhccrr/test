package com.hcr.demo.test.java;

/**
 * 功能描述：
 *
 * @Author:hr
 * @param:
 * @date: 15:07 2021/1/26 0026
 */
public class Interview {
    /**
     *功能描述：
     *
     * # Java基础
     *             1) JAVA中的几种基本数据类型是什么，各自占用多少字节。
     *               byte 1
     *               short 2
     *               int 4
     *               long 8
     *               float 4
     *               double 8
     *               char 2
     *               boolean 1
     *
     *             1) String类能被继承吗，为什么。
     *               不能，String被final修改
     *
     *             1) String，Stringbuffer，StringBuilder的区别。
     *                String:不可变字符序列
     *                Stringbuffer：可变字符序列、线程安全，方法被synchronized修饰 相对于StringBuilder速度要慢
     *                StringBuilder：可变字符序列、线程不安全、速度快
     *
     *             1) ArrayList、LinkedList、vector有什么区别。
     *                ArrayList遍历速度比LinkedList快，因为ArrayList内存的连续性，cpu的内部缓存会缓存连续的内存片段，降低读取内存的性能开销
     *
     *                ArrayList:有序可重复；允许元素为null（同下）查询、修改快；增删慢；底层是数组；线程不安全；不适合做队列，因为会涉及到数据的搬迁，比较耗费性能；ArrayList可以自动扩容，不传初始容量或者初始容量是0，都会初始化一个空数组，但是如果添加元素，会自动进行扩容，所以，创建ArrayList的时候，给初始容量是必要的
     *                LinkedList:有序可重复；允许元素为null（因为Integer是一个类，对象的值允许为空，包装类有自动装箱的功能）；查询、修改慢；增删快，底层是双向链表
     *                vector：线程安全（每个方法都被synchronized修饰）；底层是数组实现；默认扩容是原来的两倍
     *
     *             1) 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。
     *                总结：父类静态变量——>父类静态代码块——>子类静态变量——>子类静态代码块———>父类非静态变量（父类实例成员变量）——>父类构造函数——>子类非静态变量（子类实例成员变量）——>子类构造函数
     *                父类静态数据———>子类静态代码块——>父类字段——>父类构造函数——>子类字段——>子类构造函数
     *
     *             1) 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
     *               HashMap：无序；键值都可以为null
     *                   jdk7：HashMap的底层数据结构是数组和链表结合   JDK8:数组、链表、红黑树
     *                   存取原理：
     *                           存：
     *                           hashmap在存数据的时候是基于hashing的原理，当我们调用put(key,value)方法的时候，其实我们会先对键key调用key.hashcode()方法，根据方法返回的hashcode来找到bucket（bucket：俗称‘桶’，可以存储元素的位置，每个桶都有其指定索引）的位置来存Entry对象。（Entry对象存有key和value）
     *                           如果两个hashcode相同，那么它们对应的bucket显然也是相同的，这个时候就会产生所谓的碰撞（hashmap的底层存储结构是 数组+链表）。每个bucket索引对应一个链表，这个时候系统就会找到对应的链表,并在链表的尾部加上这个Entry对象
     *                           根据hashcode找到对应的bucket之后，还会在对应的链表逐一检查这个链表里有没存在相同的key对象，这个时候是通过equals这个方法来对比的。如果有，者用新的value取代旧的value。如果没有，则向楼上说的，在链表的尾部加上这个新的Entry对象。
     *                           取：
     *                           当我们调用get(key)的时候，会调用key的hashcode方法获得hashcode.
     *                           根据hashcode获取相应的bucket。
     *                           由于一个bucket对应的链表中可能存有多个Entry,这个时候会调用key的equals方法来找到对应的Entry
     *                           最后把值返回（这句好像是废话....但我还是想说下）。
     *                  如何扩容：
     *                           扩容：创建一个新的Entry空数组，长度是原数组的2倍。
     *                           ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。（因为长度扩大之后，hash规则也随之改变了）Hash的公式---> index = HashCode（Key） & （Length - 1）
     *               LinkedHashMap：extends HashMap  有序
     *
     *               HashTable：线程安全，但是并发度低，基本没啥使用场景了；不允许键值为null；初始化容量为11 负载因子默认0.75
     *
     *               CurrentHashMap：线程安全，在多线程场景由于并发度的原因使用CurrentHashMap
     *
     *
     *
     *
     *             1) JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
     *                先读取数据在判断是否修改，如果没有修改则直接修改，如果修改了则重新获取加锁操作
     *             1) 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
     *                 LinkedHashMap有序；
     *             1) 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
     *             1) 继承和聚合的区别在哪。
     *             1) IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。
     *             1) 反射的原理，反射创建类实例的三种方式是什么。
     *
     *             todo
     *             1) 反射中，Class.forName和ClassLoader区别 。
     *             1) 描述动态代理的几种实现方式，分别说出相应的优缺点。
     *             1) 动态代理与cglib实现的区别。
     *             1) 为什么CGlib方式可以对接口实现代理。
     *             1) final的用途。
     *             1) 写出三种单例模式实现 。
     *             1) 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。
     *             1) 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
     *             1) 深拷贝和浅拷贝区别。
     *             1) 数组和链表数据结构描述，各自的时间复杂度。
     *             1) error和exception的区别，CheckedException，RuntimeException的区别。
     *             1) 请列出5个运行时异常。
     *             1) 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。
     *             1) 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。
     *             1) 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
     *             1) 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。
     *             1) 有没有可能2个不相等的对象有相同的hashcode。
     *             1) Java中的HashSet内部是如何工作的。
     *             1) 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
     *             1) java8的新特性。
     *
     *
     * # JVM知识
     *             1) 情况下会发生栈内存溢出
     *             1) NM的内存结构，Eden和 Survivor比例。
     *             1) M内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor.
     *             1) JM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要
     *             1) 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优
     *             1) 垃圾回收算法的实现原理。出现了内存溢出，你怎么排错。
     *             1) JVM内存模型的相关知识了解多少，比如重排序，内存屏障， happen- before，主内存，工作内存等。
     *             1)  简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
     *             1) 你们线上应用的M参数有哪些。
     *             1) g1和cms区别吞吐量优先和响应优先的垃圾收集器选择
     *             1) 怎么打出线程栈信息。
     *             1) 请解释如下ym参数的含义
     *             1) -server-Xms512m -Xmx512m -XsS1024K
     *             1) -XX. Permsize=256m -XX. MaxPermsize=512m
     *             1) XX： MaxTenuring Threshold= 20XX： CMSInitiatingOccupancy Fraction=80
     *             1) XX： Use CMSInitiatingoccupancyonly
     *
     * # 开源框架知识
     *             1) 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
     *             1) tomcat如何调优，涉及哪些参数 。
     *             1) 讲讲Spring加载流程。
     *             1) Spring AOP的实现原理。
     *             1) 讲讲Spring事务的传播属性。
     *             1) Spring如何管理事务的。
     *             1) Spring怎么配置事务（具体说出一些关键的xml 元素）。
     *             1) 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。
     *             1) Springmvc 中DispatcherServlet初始化过程。
     *             1) netty的线程模型，netty如何基于reactor模型上实现的。
     *             1) 为什么选择netty。
     *             1) 什么是TCP粘包，拆包。解决方式是什么。
     *             1) netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
     *             1) netty的心跳处理在弱网下怎么办。
     *             1) netty的通讯协议是什么样的。
     *             1) springmvc用到的注解，作用是什么，原理。
     *             1) springboot启动机制。
     *             1) 点击这里有一套答案版的Spring试题。
     *
     *  # 操作系统
     *             1) Linux系统下你关注过哪些内核参数，说说你知道的。
     *             1) Linux下IO模型有几种，各自的含义是什么。
     *             1) epoll和poll有什么区别。
     *             1) 平时用到哪些Linux命令。
     *             1) 用一行命令查看文件的最后五行。
     *             1) 用一行命令输出正在运行的java进程。
     *             1) 介绍下你理解的操作系统中线程切换过程。
     *             1) 进程和线程的区别。
     *             1) top 命令之后有哪些内容，有什么作用。
     *             1) 线上CPU爆高，请问你如何找到问题所在。
     *
     * # 多线程
     *             1) 多线程的几种实现方式，什么是线程安全。
     *             1) volatile的原理，作用，能代替锁么。
     *              答：在生成汇编代码时会在volatile修饰共享变量进行写操作的时候会多出lock前缀指令
     *                  作用：lock前缀指令会引起处理器缓存写回内存
     *                        一个处理器的缓存写回内存会让其他处理器的缓存失效
     *                        当其他处理器发现本地缓存失效之后，会重新到内存中读取数据，就得到了最新的数据
     *                  不能代替锁，只能保证可见性，无法保证原子性（只能保证对单次读写的原子性，i++这种操作不能保证原子性）
     *             1) 画一个线程的生命周期状态图。
     *             1) sleep和wait的区别。
     *              sleep不会释放锁，时间到后会继续执行
     *              wait会放弃所有锁，需要notify()或者notifyAll()之后重新获取锁资源才能继续执行
     *             1) sleep和sleep(0)的区别。
     *             1) Lock与Synchronized的区别 。
     *             答：Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
     *                 synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
     *                 Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
     *                 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。（tryLock()）
     *                 Lock可以提高多个线程进行读操作的效率。(readWriteLock 读写锁)
     *                 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
     *
     *             1) synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。
     *             1) 用过哪些原子类，他们的原理是什么。
     *             1) JUC下研究过哪些并发工具，讲讲原理。
     *             1) 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。
     *                  newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。(根据用户的任务数创建相应的线程来处理，该线程池不会对线程数目加以限制，完全依赖于JVM能创建线程的数量，可能引起内存不足。 底层是基于ThreadPoolExecutor实现，借助reentrantlock保证并发。 coreSize核心线程数，maxsize最大线程数。)
     *                  newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待
     *                  newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
     *                  ewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
     *                  参数：
     *                  corePoolSize:线程池维护线程的最少数量(core:核心)
     *                  maximumPoolSize:线程池维护线程的最大数量 
     *                  keepAliveTime:线程池维护线程所允许的空闲时间
     *                  unit:线程池维护线程所允许的空闲时间的单位
     *                  workQueue:线程池所使用的缓冲队列
     *                  handler:线程池对拒绝任务的处理策略
     *
     *             1) 线程池的关闭方式有几种，各自的区别是什么。
     *                  shutdown():调用之后，不可以再添加新的任务，会把已经添加的全部执行完再关闭线程
     *                  shutdownNow()：调用之后会停止当前正在执行的task,并返回尚未执行的task的集合
     *             1) 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。
     *             1) spring的controller是单例还是多例，怎么保证并发的安全。
     *                是单例，尽量不要在controller中定义成员变量，
     *                非要定义非成员变量的时候通过注解@Scope("prototype")设置成多例
     *                在controller中使用ThreaderLocal变量
     *
     *             1) 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。
     *             1) ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。
     *             1) 如果让你实现一个并发安全的链表，你会怎么做。
     *             1) 有哪些无锁数据结构，他们实现的原理是什么。
     *             1) 讲讲java同步机制的wait和notify。
     *             1) CAS机制是什么，如何解决ABA问题。
     *             1) 多线程如果线程挂住了怎么办。
     *             1) countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的)。
     *             1) 对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。
     *             1) 使用synchronized修饰静态方法和非静态方法有什么区别。
     *             1) 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
     *             1) 导致线程死锁的原因？怎么解除线程死锁。
     *             1) 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。
     *             1) 用过读写锁吗，原理是什么，一般在什么场景下用。
     *             1) 开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。
     *             1) 延迟队列的实现方式，delayQueue和时间轮算法的异同。
     *             1) 点击这里有一套答案版的多线程试题。
     *
     * # TCP与HTTP
     *             1) http1.0和http1.1有什么区别。
     *             1) TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
     *             1) TIME_WAIT和CLOSE_WAIT的区别。
     *             1) 说说你知道的几种HTTP响应码，比如200, 302, 404。
     *             1) 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
     *             1) TCP/IP如何保证可靠性，说说TCP头的结构。
     *             1) 如何避免浏览器缓存。
     *             1) 如何理解HTTP协议的无状态性。
     *             1) 简述Http请求get和post的区别以及数据包格式。
     *             1) HTTP有哪些method
     *             1) 简述HTTP请求的报文格式。
     *             1) HTTP的长连接是什么意思。
     *             1) HTTPS的加密方式是什么，讲讲整个加密解密流程。
     *             1) Http和https的三次握手有什么区别。
     *             1) 什么是分块传送。
     *             1) Session和cookie的区别。
     *             1) 点击这里有一套答案版的试题。
     *
     * # 架构设计与分布式
     *             1) 用java自己实现一个LRU。
     *             1) 分布式集群下如何做到唯一序列号。
     *             1) 设计一个秒杀系统，30分钟没付款就自动关闭交易。
     *             1) 如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）
     *             1) 如果有人恶意创建非法连接，怎么解决。
     *             1) 分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。
     *             1) 什么是一致性hash。
     *             1) 什么是restful，讲讲你理解的restful。
     *             1) 如何设计一个良好的API。
     *             1) 如何设计建立和保持100w的长连接。
     *             1) 解释什么是MESI协议(缓存一致性)。
     *             1) 说说你知道的几种HASH算法，简单的也可以。
     *             1) 什么是paxos算法， 什么是zab协议。
     *             1) 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。
     *             1) 线上系统突然变得异常缓慢，你如何查找问题。
     *             1) 说说你平时用到的设计模式。
     *             1) Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现，重试转发，快速失败的策略是怎样的 。
     *             1) 一次RPC请求的流程是什么。
     *             1) 自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。
     *             1) 异步模式的用途和意义。
     *             1) 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。
     *             1) 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。
     *             1) MVC模式，即常见的MVC框架。
     *             1) 聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。
     *             1) 应用服务器怎么监控性能，各种方式的区别。
     *             1) 如何设计一套高并发支付方案，架构如何设计。
     *             1) 如何实现负载均衡，有哪些算法可以实现。
     *             1) Zookeeper的用途，选举的原理是什么。
     *             1) Zookeeper watch机制原理。
     *             1) Mybatis的底层实现原理。
     *             1) 请思考一个方案，实现分布式环境下的countDownLatch。
     *             1) 后台系统怎么防止请求重复提交。
     *             1) 描述一个服务从发布到被消费的详细过程。
     *             1) 讲讲你理解的服务治理。
     *             1) 如何做到接口的幂等性。
     *             1) 如何做限流策略，令牌桶和漏斗算法的使用场景。
     *             1) 什么叫数据一致性，你怎么理解数据一致性。
     *             1) 分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。
     *             1) dubbo的泛化调用怎么实现的，如果是你，你会怎么做。
     *             1) 远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。
     *
     * # 算法
     *             1) 10亿个数字里里面找最小的10个。
     *             1) 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。
     *             1) 2亿个随机生成的无序整数,找出中间大小的值。
     *             1) 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。
     *             1) 遍历二叉树。
     *             1) 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。
     *             1) 写一个字符串（如：www.javastack.cn）反转函数。
     *             1) 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。
     *             1) 二分查找的时间复杂度，优势。
     *             1) 一个已经构建好的TreeSet，怎么完成倒排序。
     *             1) 什么是B+树，B-树，列出实际的使用场景。
     *             1) 一个单向链表，删除倒数第N个数据。
     *             1) 200个有序的数组，每个数组里面100个元素，找出top20的元素。
     *             1) 单向链表，查找中间的那个元素。
     *
     *# 数据库知识
     *             1) 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。
     *                 读未提交（Read Uncommitted）：所有事物都可以看到其他事物未提交的执行结果（很少用于实际开发，性能比其他隔离级别好不了多少，读取未提交的数据被称为‘脏读’）
     *                 度已提交（Read Committed）：大多数数据系统的隔离级别，mysql不是）一个事物只能看见已提交事务所做的改变，这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果
     *                 可重复读（Repeatable Read）：可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响  （mysql数据库所默认的级别）
     *                 串行话（Serializable）：一个事务一个事务的执行
     *                 影响：
     *                 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
     *                 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据
     *                 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。
     *             1) 什么是幻读。
     *                  幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。
     *             1) MYSQL有哪些存储引擎，各自优缺点。
     *                MyISAM:
     *                  不支持事务、
     *                  不支持外键、非
     *                  聚集索引（索引是一张表（存的是数据表的指针），数据是一张表）
     *                  b+树
     *
     *                InnoDB：
     *                  支持事务、
     *                  支持外键、
     *                  聚集索引（主键和数据是在一起的）、
     *                  b+树
     *             1) 高并发下，如何做到安全的修改同一行数据。
     *             1) 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。
     *             1) SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。
     *             1) 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。
     *             1) MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
     *                原理：索引就是数据表中一个或多个列排序的数据结构
     *                类型：
     *                      普通类型（CREATE INDEX)
     *                      唯一索引，索引列的值必须唯一（CREATE UNIQUE INDEX)
     *                      多列索引
     *                      主键索引（PRIMARY KEY），一个表只能有一个
     *                      全文索引（FULLTEXT INDEX），InnoDB 不支持
     *                创建：
     *                      经常用作查询条件的字段
     *                      经常作用在连接表的字段
     *                      经常出现在order By、group By后的子弹
     *                优化：
     *                      字段非空，NOT NULL，mysql很难对空值做查询优化
     *                      作为索引的字段尽量不要有大量相同的值
     *                      索引长度不要太长（比较耗费时间）
     *
     *             1) 聚集索引和非聚集索引的区别。
     *             1) select for update 是什么含义，会锁表还是锁行或是其他。
     *             1) 为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。
     *             1) 数据库的ACID是什么。
     *             1) 某个表有近千万数据，CRUD比较慢，如何优化。
     *             1) Mysql怎么优化table scan的。
     *             1) 如何写sql能够有效的使用到复合索引。
     *             1) mysql中in 和exists 区别。
     *                select * from A where A.id in (select id from B)
     *                select * from A where exists (select 1 form B where A.id = B.id) B表数据大于A表数据用exists
     *                in适合A表数据大于B表数据,in()查询是从缓存中查询
     *                exists适合A表数据小于B表数据，exists()不会把查询结果放入缓存，他返回一个Boolean,只在乎exists()中是否有记录，与具体的结果集无关
     *                A表和B表数据相等的情况下，两个可以任选一个，效率差不多
     *
     *             1) 数据库自增主键可能的问题。
     *                 如果项目移植，数据库冲突较大
     *                 分库分表中可能会导致主键重复
     *
     *             1) MVCC的含义，如何实现的。
     *             1) 你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。
     *             1) MYSQL的主从延迟怎么解决。
     *
     * # 消息队列
     *             1) 消息队列的使用场景。
     *             1) 消息的重发，补充策略。
     *             1) 如何保证消息的有序性。
     *             1) 用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。
     *             1) MQ系统的数据如何保证不丢失。
     *             1) rabbitmq如何实现集群高可用。
     *             1) kafka吞吐量高的原因。
     *             1) kafka 和其他消息队列的区别，kafka 主从同步怎么实现。
     *             1) 利用mq怎么实现最终一致性。
     *             1) 使用kafka有没有遇到什么问题，怎么解决的。
     *             1) MQ有可能发生重复消费，如何避免，如何做到幂等。
     *             1) MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。
     *
     * # 缓存
     *             1) 常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。
     *             1) 如何防止缓存击穿和雪崩。
     *             1) 缓存数据过期后的更新如何设计。
     *             1) redis的list结构相关的操作。
     *             1) Redis的数据结构都有哪些。
     *             1) Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。
     *                持久化：redis为了达到最快的读写速度，将数据读到内存中，在通过异步将数据写入磁盘
     *                内存设置：如果设置了最大使用内存，当数据达到内存限值后将不能继续插入新值
     *             1) redis2和redis3的区别，redis3内部通讯机制。
     *             1) 当前redis集群有哪些玩法，各自优缺点，场景。
     *             1) Memcache的原理，哪些数据适合放在缓存中。
     *             1) redis和memcached 的内存管理的区别。
     *             1) Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
     *                  并发竞争：
     *                      1、客户端角度：对连接进行池化，同时对客户读写redis操作进行加锁（synchronized或lock）
     *                      2、服务器：利用setnx命令实现锁
     *                                  MULTI:开启事务（之后执行的命令都是事物内的操作）
     *                                  EXEC:提交 相当于commit
     *                                  DISCARD:回滚
     *             1) Redis的选举算法和流程是怎样的。
     *             1) redis的持久化的机制，aof和rdb的区别。
     *             1) redis的集群怎么同步的数据的。
     *             1) 知道哪些redis的优化操作。
     *                 Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
     *                 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
     *                 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
     *                 尽量避免在压力很大的主库上增加从库
     *                 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...
     *                  这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。
     *
     *             1) Reids的主从复制机制原理。
     *             1) Redis的线程模型是什么。
     *             1) 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。
     *             1) 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。
     *             1) 本地缓存在并发使用时的注意事项。
     *
     * # 搜索
     *             1) elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。elasticsearch的倒排索引是什么。
     *             1) elasticsearch 索引数据多了怎么办，如何调优，部署。
     *             1) elasticsearch是如何实现master选举的。
     *             1) 详细描述一下Elasticsearch索引文档的过程。
     *             1) 详细描述一下Elasticsearch搜索的过程。
     *             1) Elasticsearch在部署时，对Linux的设置有哪些优化方法？
     *             1) lucence内部结构是什么。
     */
}
